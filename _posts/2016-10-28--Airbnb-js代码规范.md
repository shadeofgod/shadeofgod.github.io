---
layout: post
title: Airbnb js代码规范（译）
image: ''
date:   2016-10-28 22:13:27
tags:
- Javascript
description: ''
categories:
- Javascript
serie: learn
---

https://github.com/airbnb/javascript

Airbnb关于JS的代码规范，缓慢翻译填坑中。

## 目录

1. 类型
2. 引用
3. 对象
4. 数组
5. [Destructuring](https://github.com/airbnb/javascript#destructuring)
6. [Strings](https://github.com/airbnb/javascript#strings)
7. [Functions](https://github.com/airbnb/javascript#functions)
8. [Arrow Functions](https://github.com/airbnb/javascript#arrow-functions)
9. [Classes & Constructors](https://github.com/airbnb/javascript#classes--constructors)
10. [Modules](https://github.com/airbnb/javascript#modules)
11. [Iterators and Generators](https://github.com/airbnb/javascript#iterators-and-generators)
12. [Properties](https://github.com/airbnb/javascript#properties)
13. [Variables](https://github.com/airbnb/javascript#variables)
14. [Hoisting](https://github.com/airbnb/javascript#hoisting)
15. [Comparison Operators & Equality](https://github.com/airbnb/javascript#comparison-operators--equality)
16. [Blocks](https://github.com/airbnb/javascript#blocks)
17. [Comments](https://github.com/airbnb/javascript#comments)
18. [Whitespace](https://github.com/airbnb/javascript#whitespace)
19. [Commas](https://github.com/airbnb/javascript#commas)
20. [Semicolons](https://github.com/airbnb/javascript#semicolons)
21. [Type Casting & Coercion](https://github.com/airbnb/javascript#type-casting--coercion)
22. [Naming Conventions](https://github.com/airbnb/javascript#naming-conventions)
23. [Accessors](https://github.com/airbnb/javascript#accessors)
24. [Events](https://github.com/airbnb/javascript#events)
25. [jQuery](https://github.com/airbnb/javascript#jquery)
26. [ECMAScript 5 Compatibility](https://github.com/airbnb/javascript#ecmascript-5-compatibility)
27. [ECMAScript 6+ (ES 2015+) Styles](https://github.com/airbnb/javascript#ecmascript-6-es-2015-styles)
28. [Testing](https://github.com/airbnb/javascript#testing)
29. [Performance](https://github.com/airbnb/javascript#performance)
30. [Resources](https://github.com/airbnb/javascript#resources)
31. [In the Wild](https://github.com/airbnb/javascript#in-the-wild)
32. [Translation](https://github.com/airbnb/javascript#translation)
33. [The JavaScript Style Guide Guide](https://github.com/airbnb/javascript#the-javascript-style-guide-guide)
34. [Chat With Us About JavaScript](https://github.com/airbnb/javascript#chat-with-us-about-javascript)
35. [Contributors](https://github.com/airbnb/javascript#contributors)
36. [License](https://github.com/airbnb/javascript#license)



## 类型

- 1.1 当你处理一个如下简单的数据类型时，你是直接对它对应的值进行操作。

  - `string`
  - `number`
  - `boolean`
  - `null`
  - `undefined`

  ```javascript
  const foo = 1;
  let bar = foo;

  bar = 9;

  console.log(foo, bar); // => 1, 9
  ```

- 1.2 当你处理一个如下复杂的数据类型时，你处理的是它的引用。

  - `object`
  - `array`
  - `function`

  ```javascript
  const foo = [1, 2];
  const bar = foo;

  bar[0] = 9;

  console.log(foo[0], bar[0]); // => 9, 9
  ```

## 引用

- 2.1 使用 `const` 来声明所有的引用，避免使用 `var`。详见 eslint: [`prefer-const`](http://eslint.org/docs/rules/prefer-const.html), [`no-const-assign`](http://eslint.org/docs/rules/no-const-assign.html)

  > 为什么？因为这样可以保证你不会重新给引用赋一个另外的值，避免以此引起的bug和对代码的理解困难

  ```javascript
  // bad
  var a = 1;
  var b = 2;

  // good
  const a = 1;
  const b = 2;
  ```


- 2.2 如果你必须要重新给一个引用赋值,，使用 `let` 而不是`var`。详见 eslint: [`no-var`](http://eslint.org/docs/rules/no-var.html) jscs: [`disallowVar`](http://jscs.info/rule/disallowVar)

  > 为什么？因为`let`是块级作用，而不像`var`有着函数作用域。

  ```javascript
  // bad
  var count = 1;
  if (true) {
    count += 1;
  }

  // good, use the let.
  let count = 1;
  if (true) {
    count += 1;
  }
  ```


- 2.3 注意，使用`let`和`const`声明的变量，都只作用于块级作用域。

  ```javascript
  // const and let only exist in the blocks they are defined in.
  {
    let a = 1;
    const b = 1;
  }
  console.log(a); // ReferenceError
  console.log(b); // ReferenceError
  ```

## 对象

- 3.1 尽量使用字面语法来直接创建对象。详见eslint: [`no-new-object`](http://eslint.org/docs/rules/no-new-object.html)

  ```javascript
  // bad
  const item = new Object();

  // good
  const item = {};
  ```


- 3.2 创建一个有着动态的属性名的对象时，尽量使用计算后的属性名。

  > 为什么？这样可以让你同时定义一个对象所有的属性

  ```javascript
  function getKey(k) {
    return `a key named ${k}`;
  }

  // bad
  const obj = {
    id: 5,
    name: 'San Francisco',
  };
  obj[getKey('enabled')] = true;

  // good
  const obj = {
    id: 5,
    name: 'San Francisco',
    [getKey('enabled')]: true,
  };
  ```


- 3.3 使用简写的属性方法。详见eslint: [`object-shorthand`](http://eslint.org/docs/rules/object-shorthand.html) jscs: [`requireEnhancedObjectLiterals`](http://jscs.info/rule/requireEnhancedObjectLiterals)

  ```javascript
  // bad
  const atom = {
    value: 1,

    addValue: function (value) {
      return atom.value + value;
    },
  };

  // good
  const atom = {
    value: 1,

    addValue(value) {
      return atom.value + value;
    },
  };
  ```


- 3.4使用简写的属性值。详见 [`object-shorthand`](http://eslint.org/docs/rules/object-shorthand.html) jscs: [`requireEnhancedObjectLiterals`](http://jscs.info/rule/requireEnhancedObjectLiterals)

  > 为什么？书写更简短，描述性更强。

  ```javascript
  const lukeSkywalker = 'Luke Skywalker';

  // bad
  const obj = {
    lukeSkywalker: lukeSkywalker,
  };

  // good
  const obj = {
    lukeSkywalker,
  };
  ```


- 3.5 把简写的属性名统一分组写在声明对象最开始的地方。

  > 为什么？这样一下就能看出来哪些属性使用了简写。

  ```javascript
  const anakinSkywalker = 'Anakin Skywalker';
  const lukeSkywalker = 'Luke Skywalker';

  // bad
  const obj = {
    episodeOne: 1,
    twoJediWalkIntoACantina: 2,
    lukeSkywalker,
    episodeThree: 3,
    mayTheFourth: 4,
    anakinSkywalker,
  };

  // good
  const obj = {
    lukeSkywalker,
    anakinSkywalker,
    episodeOne: 1,
    twoJediWalkIntoACantina: 2,
    episodeThree: 3,
    mayTheFourth: 4,
  };
  ```

- 3.6 只有在属性名是无效的标识符的时候才使用引号包起来使之成为字符串（比如数字开头或带有空格的多个词）。详见eslint: [`quote-props`](http://eslint.org/docs/rules/quote-props.html) jscs: [`disallowQuotedKeysInObjects`](http://jscs.info/rule/disallowQuotedKeysInObjects)

  > 为什么？一般主观上来说这样更容易阅读，也有利于语法高亮和一些JS引擎优化。

  ```javascript
  // bad
  const bad = {
    'foo': 3,
    'bar': 4,
    'data-blah': 5,
  };

  // good
  const good = {
    foo: 3,
    bar: 4,
    'data-blah': 5,
  };
  ```


- 3.7 尽量不要直接调用某些`Object.prototype`的方法，比如 `hasOwnProperty`, `propertyIsEnumerable`, 和`isPrototypeOf`.

  > 为什么？因为某些对象里这些方法可能被覆写了，比如这种`{ hasOwnProperty: false }` ，或者是一个null对象 (`Object.create(null)`).

  ```javascript
  // bad
  console.log(object.hasOwnProperty(key));

  // good
  console.log(Object.prototype.hasOwnProperty.call(object, key));

  // best
  const has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope.
  /* or */
  import has from 'has';
  …
  console.log(has.call(object, key));
  ```


- 3.8 浅复制对象时使用`...`操作符而不是使用 [`Object.assign`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 

  ```javascript
  // very bad
  const original = { a: 1, b: 2 };
  const copy = Object.assign(original, { c: 3 }); // this mutates `original` ಠ_ಠ
  delete copy.a; // so does this

  // bad
  const original = { a: 1, b: 2 };
  const copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }

  // good
  const original = { a: 1, b: 2 };
  const copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }

  const { a, ...noA } = copy; // noA => { b: 2, c: 3 }
  ```

## 数组

- 4.1 使用字面语法来创建数组对象。详见eslint: [`no-array-constructor`](http://eslint.org/docs/rules/no-array-constructor.html)

  ```javascript
  // bad
  const items = new Array();

  // good
  const items = [];
  ```


- 4.2 使用`push()`方法来添加元素而不是直接赋值。

  ```javascript
  const someStack = [];

  // bad
  someStack[someStack.length] = 'abracadabra';

  // good
  someStack.push('abracadabra');
  ```


- 4.3 使用`...`操作符来复制数组。

  ```javascript
  // bad
  const len = items.length;
  const itemsCopy = [];
  let i;

  for (i = 0; i < len; i++) {
    itemsCopy[i] = items[i];
  }

  // good
  const itemsCopy = [...items];
  ```


- 4.4 使用`Array.from()`来把一个类数组转化成数组。

  ```javascript
  const foo = document.querySelectorAll('.foo');
  const nodes = Array.from(foo);
  ```


- 4.5 数组方法的回调函数里使用return声明。除非像8.2那样函数内只有一句表达的时候可以删去return，详见 [`array-callback-return`](http://eslint.org/docs/rules/array-callback-return)

  ```javascript
  // bad
  [1, 2, 3].map((x) => {
    const y = x + 1;
    return x * y;
  });

  // good
  [1, 2, 3].map(x => x + 1);

  // bad
  const flat = {};
  [[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) => {
    const flatten = memo.concat(item);
    flat[index] = flatten;
  });

  // good
  const flat = {};
  [[0, 1], [2, 3], [4, 5]].reduce((memo, item, index) => {
    const flatten = memo.concat(item);
    flat[index] = flatten;
    return flatten;
  });

  // bad
  inbox.filter((msg) => {
    const { subject, author } = msg;
    if (subject === 'Mockingbird') {
      return author === 'Harper Lee';
    } else {
      return false;
    }
  });

  // good
  inbox.filter((msg) => {
    const { subject, author } = msg;
    if (subject === 'Mockingbird') {
      return author === 'Harper Lee';
    }

    return false;
  });
  ```